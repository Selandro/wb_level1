package main

import "fmt"

//реализация функции бинарного поиска, которая делит массив пополам
//и ищет по центральному значанию в новых массивах, если число меньше,
//то ищет в левой части, если больше, то в правой, рекурсивно разделяя
//подмассив на новые массивы
func binarySearch(arr []int, target int) (int, error) {

	//бинарный поиск работает только с отсортированными массивами
	//следовательно нужно ввести проверку отсортирован ли массив
	n := len(arr)
	for i := 0; i < n-1; i++ {
		if arr[i] > arr[i+1] {
			return -1, fmt.Errorf("массив не отсортирован")
		}
	}
	//задаем первоначальные индексы самого маленького и самого большого элемента
	left, right := 0, len(arr)-1

	for left <= right {
		//разделяем массив на 2 части
		mid := (left + right) / 2

		if arr[mid] == target {
			//элемент найден
			return mid, nil // Элемент найден
		} else if arr[mid] < target {
			//ищем в правой половине
			left = mid + 1
		} else {
			//ищем в левой половине
			right = mid - 1
		}
	}

	return -1, nil
}

func main() {

	//массив данных для сортировки
	arrayOne := []int{4, 1, 2, 53, 23, 123, 62, -12, -11, 10, 12, 11, 0, 100, -1000}
	arrayTwo := []int{-1000, -12, -11, 0, 1, 2, 4, 10, 11, 12, 23, 53, 62, 100, 123}

	//запускаем бинарный поиск не отсортированного массива
	index1, err := binarySearch(arrayOne, 4)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("найденный жлемент имеет индекс: %d", index1)
	}

	//запускаем бинарный поиск отсортированного массива
	index2, err := binarySearch(arrayTwo, 4)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("найденный жлемент имеет индекс: %d", index2)
	}

}
